# 输入框刷新机制问题分析

## 问题描述
输入框（PromptInput）在输入字符（包括退格）时会导致整个TUI界面重新渲染，之前的UI元素遗留在上面，造成视觉残留和性能问题。

## 根本原因分析

### 1. 状态管理机制缺陷
- **REPLStateManager** 使用发布-订阅模式管理状态
- **setInputValue** 方法调用 **updateState**，触发状态比较和监听器通知
- 每次输入字符变化都会导致状态更新，即使内容没有实质性变化

### 2. 组件渲染机制问题
- **REPL.tsx** 组件订阅整个状态变化
- 任何状态更新都会触发 **setState**，导致整个组件树重新渲染
- 输入框字符变化不应该触发整个界面的重渲染

### 3. 消息渲染优化不足
- **MessageRenderer** 组件使用 **useMemo** 优化，但依赖项过多
- 输入框变化不应该影响消息列表的渲染
- 静态消息和动态消息的区分机制不够完善

## 技术细节

### REPLStateManager.ts 关键代码
```typescript
setInputValue(inputValue: string): void {
    this.updateState(state => ({ ...state, inputValue }))
}

updateState(updater: (state: REPLState) => REPLState): void {
    const newState = updater({ ...this.state })
    
    // JSON.stringify 比较性能开销大
    if (JSON.stringify(this.state) !== JSON.stringify(newState)) {
        this.state = newState
        this.notifyListeners() // 触发所有监听器
    }
}
```

### REPL.tsx 状态订阅
```typescript
// 订阅整个状态变化
useEffect(() => {
    const unsubscribe = stateManager.subscribe((newState: REPLState) => {
        setState(newState) // 触发整个组件重渲染
    })
    return unsubscribe
}, [stateManager])
```

## 解决方案建议

### 短期修复
1. **优化状态比较**：使用浅比较或特定字段比较代替 JSON.stringify
2. **分离状态订阅**：为输入值创建独立的状态管理通道
3. **优化 useMemo 依赖项**：减少不必要的依赖项触发重渲染

### 长期重构
1. **状态管理分层**：将输入状态与其他业务状态分离
2. **组件结构优化**：使用更细粒度的组件和状态管理
3. **渲染性能优化**：实现更智能的差异渲染机制

## 影响评估
- **性能影响**：频繁的状态比较和重渲染消耗大量CPU资源
- **用户体验**：视觉残留和闪烁影响使用体验
- **内存占用**：不必要的组件实例化和销毁增加内存压力

## 测试建议
1. 输入性能测试：测量输入延迟和CPU占用
2. 内存泄漏测试：验证长时间使用的内存稳定性
3. 视觉一致性测试：确保UI渲染无残留和闪烁