# 用户输入与系统信息分离实施计划

## 项目概述

本计划详细说明如何实现用户输入与系统信息的清晰分离，确保导出的日志能够明确区分用户原始输入和系统自动生成的内容。

## 实施目标

1. **消息类型清晰分离**：用户消息和系统消息使用不同的类型标识
2. **日志导出格式统一**：导出的JSON日志包含明确的角色标识
3. **向后兼容**：确保现有功能不受影响
4. **易于扩展**：为未来消息类型扩展奠定基础

## 技术架构修改

### 1. 类型定义扩展

**文件：`src/types/logs.ts`**
```typescript
// 修改前
type MessageType = 'user' | 'assistant' | 'progress';

// 修改后  
type MessageType = 'user' | 'assistant' | 'progress' | 'system';

interface SerializedMessage {
  type: MessageType;
  uuid: UUID;
  message?: {
    content: string | Array<{ type: string; text?: string }>;
    role: 'user' | 'assistant' | 'system'; // 保持现有role字段
  };
  // ... 其他元数据字段保持不变
}
```

**文件：`src/types/conversation.ts`**
```typescript
// 添加SystemMessage接口
export interface SystemMessage {
  type: 'system';
  uuid: UUID;
  message: {
    role: 'system';
    content: string;
  };
  timestamp: string;
  // 可选的元数据字段
  costUSD?: number;
  durationMs?: number;
}

// 更新Message联合类型
export type Message = UserMessage | AssistantMessage | ProgressMessage | SystemMessage;
```

### 2. 消息创建函数

**文件：`src/utils/messages.tsx`**
```typescript
// 添加系统消息创建函数
export function createSystemMessage(content: string): SystemMessage {
  return {
    type: 'system',
    uuid: randomUUID(),
    message: {
      role: 'system',
      content: content
    },
    timestamp: new Date().toISOString()
  };
}

// 更新createUserMessage以支持元数据（可选）
export function createUserMessage(
  content: string, 
  options?: {
    isEnhanced?: boolean;
    originalContent?: string;
    systemAdditions?: string;
  }
): UserMessage {
  return {
    type: 'user',
    uuid: randomUUID(),
    message: {
      role: 'user',
      content: content
    },
    options: options,
    timestamp: new Date().toISOString()
  };
}
```

### 3. 核心逻辑修改

**文件：`src/query.ts`**
```typescript
// 修改系统提醒注入逻辑（约第200-220行）
markPhase('SYSTEM_PROMPT_BUILD');

const { systemPrompt: fullSystemPrompt, reminders } =
  formatSystemPromptWithContext(systemPrompt, context, toolUseContext.agentId);

// 发射会话启动事件
emitReminderEvent('session:startup', {
  agentId: toolUseContext.agentId,
  messages: messages.length,
  timestamp: Date.now(),
});

// 修改：创建独立的系统消息而不是注入到用户消息中
if (reminders && reminders.trim().length > 0) {
  const systemMessage = createSystemMessage(reminders);
  messages.push(systemMessage);
}

markPhase('LLM_PREPARATION');
```

### 4. 日志处理增强

**文件：`src/utils/log.ts`**
```typescript
// appendToLog和overwriteLog函数已经支持任意对象类型
// 无需修改，系统消息会被正确序列化

// 可选：添加日志导出时的内容分离功能
export function exportLogWithSeparation(messages: SerializedMessage[]): any[] {
  return messages.map(msg => {
    // 如果需要进一步处理混合内容，可以在这里实现
    return msg;
  });
}
```

### 5. 调试日志更新

**文件：`src/utils/debugLogger.ts`**
```typescript
// 在logLLMInteraction函数中更新消息显示逻辑
recentMessages.forEach((msg, index) => {
  const globalIndex = context.messages.length - recentMessages.length + index;
  const roleColor = 
    msg.role === 'user' ? 'green' :
    msg.role === 'assistant' ? 'blue' :
    msg.role === 'system' ? 'yellow' : // 添加系统消息颜色
    'gray';
  
  // 系统消息特殊显示
  if (msg.role === 'system') {
    console.log(chalk[roleColor](`[${globalIndex}] ${icon} SYSTEM: ${msg.content.substring(0, 200)}...`));
  } else {
    // 原有逻辑
  }
});
```

## 实施时间表

### 第1天：基础架构准备（4小时）

- [ ] 创建类型定义扩展（1小时）
- [ ] 添加系统消息创建函数（1小时）
- [ ] 编写基础单元测试（2小时）

### 第2天：核心逻辑修改（6小时）

- [ ] 修改query.ts中的提醒注入逻辑（2小时）
- [ ] 更新相关导入和类型引用（2小时）
- [ ] 编写集成测试（2小时）

### 第3天：日志和调试增强（4小时）

- [ ] 更新调试日志显示（2小时）
- [ ] 验证日志导出格式（2小时）

### 第4天：测试和验证（4小时）

- [ ] 完整功能测试（2小时）
- [ ] 回归测试确保兼容性（2小时）

## 测试计划

### 单元测试

```typescript
// 测试系统消息创建
describe('createSystemMessage', () => {
  it('应该创建正确的系统消息结构', () => {
    const content = '系统提醒内容';
    const message = createSystemMessage(content);
    
    expect(message.type).toBe('system');
    expect(message.message.role).toBe('system');
    expect(message.message.content).toBe(content);
    expect(message.uuid).toBeDefined();
    expect(message.timestamp).toBeDefined();
  });
});

// 测试提醒注入逻辑
describe('reminder injection', () => {
  it('应该创建独立系统消息而不是修改用户消息', async () => {
    // 模拟带有提醒的查询
    const result = await queryWithReminders();
    
    // 验证系统消息存在
    const systemMessages = result.messages.filter(m => m.type === 'system');
    expect(systemMessages.length).toBe(1);
    
    // 验证用户消息未被修改
    const userMessages = result.messages.filter(m => m.type === 'user');
    userMessages.forEach(msg => {
      expect(msg.message.content).not.toContain('<system-reminder>');
    });
  });
});
```

### 集成测试

```typescript
// 测试完整的消息流程
describe('full message flow', () => {
  it('应该保持消息类型分离 throughout the conversation', async () => {
    const conversation = await simulateFullConversation();
    
    // 检查所有消息类型
    const messageTypes = conversation.messages.map(m => m.type);
    expect(messageTypes).toContain('system');
    expect(messageTypes).toContain('user');
    expect(messageTypes).toContain('assistant');
    
    // 验证系统消息内容
    const systemMsg = conversation.messages.find(m => m.type === 'system');
    expect(systemMsg.message.content).toContain('<system-reminder>');
  });
});
```

### 日志导出测试

```typescript
// 测试日志导出格式
describe('log export', () => {
  it('导出的日志应该包含分离的消息类型', () => {
    const messages = getTestMessages(); // 包含混合消息
    const exported = exportLog(messages);
    
    const exportedTypes = exported.map(m => m.type);
    expect(exportedTypes).toEqual(['system', 'user', 'assistant']);
    
    // 验证系统消息标识
    const systemMsg = exported.find(m => m.type === 'system');
    expect(systemMsg.message.role).toBe('system');
  });
});
```

## 风险评估和缓解措施

### 风险1：类型兼容性问题
- **风险**：新增消息类型可能破坏现有代码
- **缓解**：逐步实施，充分测试，确保类型检查通过

### 风险2：性能影响
- **风险**：增加消息数量可能轻微影响性能
- **缓解**：消息数量增加有限，影响可忽略

### 风险3：UI组件兼容性
- **风险**：现有UI组件可能不支持系统消息显示
- **缓解**：检查并更新相关UI组件，或保持向后兼容

## 部署策略

1. **分阶段部署**：先在不影响生产的环境测试
2. **功能开关**：可考虑添加功能开关控制新行为
3. **监控**：部署后密切监控日志系统和消息流程

## 成功标准

1. ✅ 导出的日志中用户输入和系统信息明确分离
2. ✅ 所有现有功能保持正常工作
3. ✅ 系统消息在调试日志中正确显示
4. ✅ 性能指标在可接受范围内
5. ✅ 代码质量符合项目标准

## 后续优化

1. **消息分类细化**：进一步细分系统消息类型（错误、提醒、状态等）
2. **元数据增强**：为消息添加更多上下文信息
3. **导出格式优化**：提供多种导出格式选项
4. **分析工具**：开发基于分离消息的日志分析工具

## 负责人

- **架构设计**：AI助手
- **代码实现**：开发团队  
- **测试验证**：质量保证团队
- **部署监控**：运维团队

## 时间节点

- **开始日期**：2025年1月27日
- **预计完成**：2025年1月30日
- **上线日期**：2025年2月3日（经过充分测试后）