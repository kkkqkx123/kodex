# 用户输入与系统信息分离方案

## 问题分析

当前日志系统中，用户输入和系统自动生成的信息（如错误提示、工具调用说明、系统提醒等）在导出的日志中没有明确区分，都使用相同的消息格式记录。

## 当前状态

### 消息类型定义（`src/types/logs.ts`）
```typescript
interface SerializedMessage {
  type: 'user' | 'assistant' | 'progress'
  uuid: UUID
  message?: {
    content: string | Array<{ type: string; text?: string }>
    role: 'user' | 'assistant' | 'system'  // 已存在role字段区分
  }
  // ...其他元数据
}
```

### 系统提醒生成（`src/services/systemReminder.ts`）
系统提醒消息使用 `role: 'system'` 标识：
```typescript
private createReminderMessage(): ReminderMessage {
  return {
    role: 'system',  // 正确标识为系统消息
    content: `<system-reminder>\n${content}\n</system-reminder>`,
    isMeta: true,
    // ...其他字段
  }
}
```

### 问题所在（`src/query.ts`）
系统提醒被注入到用户消息中，导致角色信息丢失：
```typescript
// 系统提醒被注入到最后一个用户消息中
const newUserMessage: UserMessage = {
  ...lastUserMessage,
  message: {
    ...lastUserMessage.message,
    content: typeof lastUserMessage.message.content === 'string'
      ? reminders + lastUserMessage.message.content  // 角色信息被覆盖
      : [
        { type: 'text', text: reminders },
        ...lastUserMessage.message.content
      ],
  },
}
```

## 解决方案

### 方案一：修改消息注入逻辑（推荐）

#### 1. 修改 `src/query.ts` 中的提醒注入逻辑

```typescript
// 修改前：将提醒注入到用户消息中
if (reminders && messages.length > 0) {
  // 查找最后一个用户消息
  for (let i = messages.length - 1; i >= 0; i--) {
    if (messages[i]?.type === 'user') {
      // 将提醒内容注入到用户消息中（错误做法）
      // ...
    }
  }
}

// 修改后：创建独立的系统消息
if (reminders && reminders.trim().length > 0) {
  const systemMessage: SystemMessage = {
    type: 'system',
    uuid: randomUUID(),
    message: {
      role: 'system',
      content: reminders
    },
    timestamp: new Date().toISOString()
  };
  messages.push(systemMessage);
}
```

#### 2. 扩展消息类型定义

在 `src/types/logs.ts` 中添加系统消息类型：
```typescript
interface SerializedMessage {
  type: 'user' | 'assistant' | 'progress' | 'system'  // 添加system类型
  // ...其他字段保持不变
}
```

#### 3. 修改日志记录逻辑

在 `src/utils/log.ts` 中确保系统消息正确处理：
```typescript
// 在appendToLog和overwriteLog中，系统消息会保持其角色标识
```

### 方案二：增强现有消息的元数据标识

#### 1. 在用户消息中添加来源标识

```typescript
// 修改用户消息创建函数（src/utils/messages.tsx）
function createUserMessage(content: string, options?: {
  isEnhanced?: boolean;    // 是否包含系统增强内容
  originalContent?: string; // 原始用户输入
  systemAdditions?: string; // 系统添加的内容
}) {
  // ...
}
```

#### 2. 修改日志导出格式

在日志导出时根据元数据分离内容：
```typescript
function exportLogWithSeparation(messages: SerializedMessage[]) {
  return messages.map(msg => {
    if (msg.type === 'user' && msg.options?.isEnhanced) {
      return {
        ...msg,
        userContent: msg.options.originalContent,
        systemContent: msg.options.systemAdditions
      };
    }
    return msg;
  });
}
```

## 实施步骤

### 第一阶段：核心逻辑修改（1-2天）

1. **修改消息类型定义**
   - 在 `src/types/logs.ts` 中添加 `'system'` 类型
   - 在 `src/types/conversation.ts` 中添加 `SystemMessage` 接口

2. **修改系统提醒注入逻辑**
   - 修改 `src/query.ts` 中的提醒处理逻辑
   - 创建独立的系统消息而不是注入到用户消息中

3. **更新消息创建函数**
   - 在 `src/utils/messages.tsx` 中添加 `createSystemMessage` 函数

### 第二阶段：日志处理增强（1天）

1. **修改日志记录逻辑**
   - 确保 `appendToLog` 和 `overwriteLog` 正确处理系统消息

2. **更新日志导出功能**
   - 修改日志导出逻辑以保持消息分离

3. **更新调试日志**
   - 修改 `src/utils/debugLogger.ts` 以正确显示分离的消息

### 第三阶段：测试和验证（1天）

1. **单元测试**
   - 添加测试用例验证消息分离功能

2. **集成测试**
   - 测试完整的消息流程
   - 验证日志导出格式

3. **回归测试**
   - 确保现有功能不受影响

## 预期效果

### 修改前日志格式
```json
{
  "type": "user",
  "message": {
    "role": "user",
    "content": "<system-reminder>系统提醒内容</system-reminder>用户原始输入"
  }
}
```

### 修改后日志格式
```json
// 系统消息
{
  "type": "system", 
  "message": {
    "role": "system",
    "content": "<system-reminder>系统提醒内容</system-reminder>"
  }
},
// 用户消息
{
  "type": "user",
  "message": {
    "role": "user", 
    "content": "用户原始输入"
  }
}
```

## 风险评估

1. **兼容性风险**：修改消息类型可能影响现有的日志处理工具
2. **性能影响**：增加独立消息可能轻微增加消息数量
3. **用户体验**：需要确保UI组件能够正确处理系统消息

## 备选方案

如果修改核心逻辑风险较大，可以考虑在日志导出时进行内容解析：

```typescript
// 在日志导出时解析和分离内容
function separateSystemContent(messages: SerializedMessage[]) {
  return messages.map(msg => {
    if (msg.type === 'user' && typeof msg.message?.content === 'string') {
      const content = msg.message.content;
      const systemMatch = content.match(/<system-reminder>([\s\S]*?)<\/system-reminder>/);
      
      if (systemMatch) {
        return [
          // 系统部分
          {
            type: 'system',
            message: { role: 'system', content: systemMatch[0] },
            timestamp: msg.timestamp
          },
          // 用户部分
          {
            ...msg,
            message: {
              ...msg.message,
              content: content.replace(systemMatch[0], '').trim()
            }
          }
        ];
      }
    }
    return msg;
  }).flat();
}
```

## 推荐方案

推荐采用**方案一**（修改核心逻辑），因为：

1. **根本解决**：从源头上区分消息类型
2. **清晰明确**：每种消息都有明确的类型标识
3. **易于维护**：后续开发和调试更加简单
4. **扩展性好**：为未来添加更多消息类型奠定基础

实施优先级：高
预计工时：3-4人天