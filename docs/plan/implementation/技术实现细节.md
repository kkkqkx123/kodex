# 技术实现细节

## 状态管理重构

### 1. 创建 InputStateManager

**文件位置**: `src/screens/REPL/InputStateManager.ts`

```typescript
import { shallowEqual } from '../../utils/object';

export interface InputState {
  value: string;
  offset: number;
  isComposing: boolean;
  selection: { start: number; end: number };
}

export class InputStateManager {
  private state: InputState;
  private listeners: Set<(state: InputState) => void>;

  constructor(initialState: Partial<InputState> = {}) {
    this.state = {
      value: '',
      offset: 0,
      isComposing: false,
      selection: { start: 0, end: 0 },
      ...initialState
    };
    this.listeners = new Set();
  }

  getState(): InputState {
    return { ...this.state };
  }

  updateState(updater: (prev: InputState) => InputState): void {
    const newState = updater(this.state);
    
    // 使用浅比较避免不必要的更新
    if (!shallowEqual(this.state, newState)) {
      this.state = newState;
      this.notifyListeners();
    }
  }

  setValue(value: string): void {
    this.updateState(prev => ({
      ...prev,
      value,
      offset: Math.min(prev.offset, value.length)
    }));
  }

  setOffset(offset: number): void {
    this.updateState(prev => ({
      ...prev,
      offset: Math.max(0, Math.min(offset, prev.value.length))
    }));
  }

  setSelection(selection: { start: number; end: number }): void {
    this.updateState(prev => ({
      ...prev,
      selection
    }));
  }

  setIsComposing(isComposing: boolean): void {
    this.updateState(prev => ({
      ...prev,
      isComposing
    }));
  }

  subscribe(listener: (state: InputState) => void): () => void {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  private notifyListeners(): void {
    const state = this.getState();
    this.listeners.forEach(listener => listener(state));
  }
}
```

### 2. 工具函数 - 浅比较

**文件位置**: `src/utils/object.ts`

```typescript
export function shallowEqual(objA: any, objB: any): boolean {
  if (Object.is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null ||
      typeof objB !== 'object' || objB === null) {
    return false;
  }

  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  for (let i = 0; i < keysA.length; i++) {
    const key = keysA[i];
    if (!Object.prototype.hasOwnProperty.call(objB, key) ||
        !Object.is(objA[key], objB[key])) {
      return false;
    }
  }

  return true;
}
```

## 组件重构

### 1. REPL组件拆分

**文件位置**: `src/screens/REPL.tsx`

```typescript
// 导入新的状态管理器
import { InputStateManager } from './REPL/InputStateManager';

// 在REPL组件中初始化输入状态管理器
const REPL: React.FC<Props> = ({ stateManager, ...props }) => {
  const [state, setState] = useState(stateManager.getState());
  const inputStateManagerRef = useRef(new InputStateManager());

  // 订阅输入状态变化
  useEffect(() => {
    const unsubscribe = inputStateManagerRef.current.subscribe(setState);
    return unsubscribe;
  }, []);

  // 其他逻辑保持不变...
}
```

### 2. 创建 InputContainer 组件

**文件位置**: `src/screens/REPL/InputContainer.tsx`

```typescript
import React, { memo, useCallback } from 'react';
import { InputState } from './InputStateManager';
import PromptInput from '../components/PromptInput';

interface InputContainerProps {
  inputState: InputState;
  onInputChange: (value: string) => void;
  onOffsetChange: (offset: number) => void;
  onSubmit: () => void;
}

const InputContainer: React.FC<InputContainerProps> = memo(({
  inputState,
  onInputChange,
  onOffsetChange,
  onSubmit
}) => {
  const handleInputChange = useCallback((value: string) => {
    onInputChange(value);
  }, [onInputChange]);

  const handleOffsetChange = useCallback((offset: number) => {
    onOffsetChange(offset);
  }, [onOffsetChange]);

  return (
    <PromptInput
      value={inputState.value}
      offset={inputState.offset}
      onChange={handleInputChange}
      onOffsetChange={handleOffsetChange}
      onSubmit={onSubmit}
      isComposing={inputState.isComposing}
    />
  );
});

InputContainer.displayName = 'InputContainer';

export default InputContainer;
```

### 3. 创建 MessageContainer 组件

**文件位置**: `src/screens/REPL/MessageContainer.tsx`

```typescript
import React, { memo, useMemo } from 'react';
import MessageRenderer from './MessageRenderer';

interface MessageContainerProps {
  messages: Message[];
  normalizedMessages: NormalizedMessage[];
}

const MessageContainer: React.FC<MessageContainerProps> = memo(({
  messages,
  normalizedMessages
}) => {
  const messageRendererProps = useMemo(() => ({
    messages,
    normalizedMessages,
    // 其他props...
  }), [messages, normalizedMessages]);

  return <MessageRenderer {...messageRendererProps} />;
});

MessageContainer.displayName = 'MessageContainer';

export default MessageContainer;
```

## 性能优化

### 1. useMemo 依赖优化

```typescript
// 优化前的useMemo（问题：依赖项过多）
const normalizedMessages = useMemo(() => 
  normalizeMessages(messages, models),
  [messages, models]
);

// 优化后的useMemo（使用更精确的依赖）
const normalizedMessages = useMemo(() => 
  normalizeMessages(messages, models),
  [messages.length, JSON.stringify(models)] // 更精确的依赖
);
```

### 2. 事件处理函数优化

```typescript
// 优化前：每次渲染都创建新函数
const handleInputChange = (value: string) => {
  setInputValue(value);
};

// 优化后：使用useCallback
const handleInputChange = useCallback((value: string) => {
  setInputValue(value);
}, []);
```

## 测试方案

### 1. 单元测试

**文件位置**: `src/screens/REPL/__tests__/InputStateManager.test.ts`

```typescript
import { InputStateManager } from '../InputStateManager';

describe('InputStateManager', () => {
  it('应该正确初始化状态', () => {
    const manager = new InputStateManager();
    expect(manager.getState()).toEqual({
      value: '',
      offset: 0,
      isComposing: false,
      selection: { start: 0, end: 0 }
    });
  });

  it('应该只在状态变化时通知监听器', () => {
    const manager = new InputStateManager();
    const listener = jest.fn();
    
    manager.subscribe(listener);
    manager.setValue('test'); // 应该触发
    manager.setValue('test'); // 不应该触发（值相同）
    
    expect(listener).toHaveBeenCalledTimes(1);
  });
});
```

### 2. 性能测试

**文件位置**: `src/screens/REPL/__tests__/performance.test.ts`

```typescript
describe('性能测试', () => {
  it('输入状态更新应该快速', () => {
    const manager = new InputStateManager();
    const startTime = performance.now();
    
    for (let i = 0; i < 1000; i++) {
      manager.setValue(`test${i}`);
    }
    
    const endTime = performance.now();
    expect(endTime - startTime).toBeLessThan(100); // 100ms内完成1000次更新
  });
});
```

## 迁移计划

1. **第一阶段**: 实现 InputStateManager 和工具函数
2. **第二阶段**: 重构 REPL 组件，逐步替换状态管理
3. **第三阶段**: 优化组件渲染和事件处理
4. **第四阶段**: 全面测试和性能验证

## 回滚方案

如果重构过程中出现问题，可以：

1. 恢复使用原来的 REPLStateManager
2. 回退组件拆分更改
3. 保持接口兼容性以便快速回滚

---

*本文档将随着实现进展持续更新*